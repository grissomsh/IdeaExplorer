In-memory Meta Data Agent for GreenPlum
In the current version of the GreenPlum Database, the queries are planned and executed using all nodes working together in a highly coordinated fashion. This has an overhead of query execution on the nodes that doesn’t have data records satisfying the que
It stroked idea when I attended a presentation on GreeenPlum Architecture from EMC IT team.
In the current version of the GreenPlum Database, the queries are planned and executed using all nodes working together in a highly coordinated fashion. This has an overhead of query execution on the nodes that doesn’t have data records satisfying the query criteria. This overhead of query execution can be avoided on all nodes by have an “In-memory meta data agent” which would have a mapping table in-memory consists of a meta data table containing information such as table name, partition name, index range, record ids. This “In-memory meta data agent” will run along with the master node and would be integrated with query execution step as an interceptor or pre-condition in order to get Meta data about the location of the relevant records for the query criteria’s to execute any query on the required partitions rather on all the partitions.

At the heart of the GreenPlum Database is the Parallel Dataflow Engine. This is where the real work of processing and analyzing data is done. The Parallel Dataflow Engine is an optimized parallel processing infrastructure that is designed to process data as it flows from disk, from external files or applications, or from other segments over the gNet interconnect. GreenPlum Parallel Dataflow Engine is highly optimized at executing both SQL and MapReduce, and does so in a massively parallel manner. So the CallbackHandler needs to passed on to the Dataflow Engine and the engine should set the location of the data records based on their id / index column values and segment ids. This would be used by the Meta Data Agent to store the Meta data into the in-memory table. 
Since Meta Data agent is going to be a cluster, we are going to avoid single point of failure and make sure the high availability of the agent. Each Meta Data Agent has its own Meta data table in memory and these agents sync with each other on a separate thread asynchronously.
The following diagram shows how we can use the Meta Data Agent and CallbackHandler to handle the Meta data information persistence.
6.1	Novel aspect 1
This aspect will be an existing feature in In-memory database, but it is missing on GreenPlum which can be incorporated so that the round trip time for the query execution on GreenPlum gets reduced by 50% if there are 4 segments and Met
